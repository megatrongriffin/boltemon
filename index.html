<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Battle Mode Game</title>
    <link rel="icon" href="data:,"> <!-- Prevents favicon 404 error -->
    <style>
        body#game-body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: black;
            overflow: hidden;
        }
        div#game-container {
            width: 100%;
            height: 100%;
        }
        canvas#game-canvas {
            display: block;
        }
    </style>
</head>
<body id="game-body">
    <div id="game-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script>
        // Controller Detection Scene
        class ControllerDetectionScene extends Phaser.Scene {
            constructor() {
                super({ key: 'ControllerDetectionScene' });
            }

            create() {
                this.add.text(this.game.config.width / 2, this.game.config.height / 2 - 50, 'Press any button on your controller to detect it', {
                    fontSize: '24px',
                    color: '#ffffff'
                }).setOrigin(0.5);

                this.player1Pad = null;
                this.player2Pad = null;
                this.controllersDetected = false;

                if (this.input.gamepad) {
                    this.input.gamepad.on('down', (pad, button) => {
                        if (!this.player1Pad) {
                            this.player1Pad = pad;
                            this.add.text(this.game.config.width / 2, this.game.config.height / 2, 'Player 1 Controller Detected', {
                                fontSize: '24px',
                                color: '#00ff00'
                            }).setOrigin(0.5);
                            this.controllersDetected = true;
                        } else if (!this.player2Pad && pad !== this.player1Pad) {
                            this.player2Pad = pad;
                            this.add.text(this.game.config.width / 2, this.game.config.height / 2 + 50, 'Player 2 Controller Detected', {
                                fontSize: '24px',
                                color: '#00ff00'
                            }).setOrigin(0.5);
                            this.controllersDetected = true;
                        }

                        // Allow Start button to proceed if at least one controller is detected
                        if (button.index === 9 && this.controllersDetected) {
                            this.scene.start('StartScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad });
                        }
                    });
                } else {
                    console.warn('Gamepad plugin not available');
                }

                this.add.text(this.game.config.width / 2, this.game.config.height - 50, 'Press SPACE or START to continue', {
                    fontSize: '20px',
                    color: '#ffffff'
                }).setOrigin(0.5);

                this.input.keyboard.on('keydown-SPACE', () => {
                    this.scene.start('StartScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad });
                });
            }
        }

        // Start Scene
        class StartScene extends Phaser.Scene {
            constructor() {
                super({ key: 'StartScene' });
            }

            init(data) {
                this.player1Pad = data.player1Pad || null;
                this.player2Pad = data.player2Pad || null;
            }

            preload() {
                this.load.image('titlebg', '/boltemon/assets/titlebg.png');
                this.load.image('battlebg', '/boltemon/assets/battlebg.jpg');
                this.load.image('floor', '/boltemon/assets/floor.png');
                this.load.image('floorleft', '/boltemon/assets/floorleft.png');
                this.load.image('floorright', '/boltemon/assets/floorright.png');
                this.load.image('buttonBlue', '/boltemon/assets/buttonBlue.png');
                this.load.image('buttonBlue_pressed', '/boltemon/assets/buttonBlue_pressed.png');
                this.load.image('coinGold', '/boltemon/assets/coinGold.png');
                this.load.image('cherry', '/boltemon/assets/cherry.png');
                this.load.image('eevee-kick', '/boltemon/assets/eevee-kick.png');

                this.load.spritesheet('pikachustanding', '/boltemon/assets/pikachustanding.png', { frameWidth: 64, frameHeight: 64 });
                this.load.spritesheet('pikachujumping', '/boltemon/assets/pikachujumping.png', { frameWidth: 64, frameHeight: 64 });
                this.load.spritesheet('pikachurunning', '/boltemon/assets/pikachurunning.png', { frameWidth: 64, frameHeight: 64 });
                this.load.spritesheet('pikachuattack', '/boltemon/assets/pikachuattack.png', { frameWidth: 64, frameHeight: 64 });
                this.load.spritesheet('eevee-standing', '/boltemon/assets/eevee-standing.png', { frameWidth: 64, frameHeight: 64 });
                this.load.spritesheet('eevee-walking', '/boltemon/assets/eevee-walking.png', { frameWidth: 64, frameHeight: 64 });
                this.load.spritesheet('eevee-winning', '/boltemon/assets/eevee-winning.png', { frameWidth: 64, frameHeight: 64 });

                this.load.audio('jump', '/boltemon/assets/jump.mp3');
                this.load.audio('squish', '/boltemon/assets/squish.mp3');
                this.load.audio('buttonPress', '/boltemon/assets/buttonPress.mp3');
                this.load.audio('coin', '/boltemon/assets/coin.mp3');
                this.load.audio('pause', '/boltemon/assets/pause.mp3');
                this.load.audio('select', '/boltemon/assets/select.mp3');
            }

            create() {
                const bg = this.add.image(this.game.config.width / 2, this.game.config.height / 2, 'titlebg');
                const scale = this.game.config.height / bg.height;
                bg.setScale(scale);

                this.battleText = this.add.text(this.game.config.width / 2, this.game.config.height / 2 - 50, 'BATTLE MODE', {
                    fontSize: '32px',
                    color: '#ffffff'
                }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                this.battleText.setInteractive();
                this.battleText.on('pointerover', () => this.battleText.setStyle({ color: '#ff0000' }));
                this.battleText.on('pointerout', () => this.battleText.setStyle({ color: '#ffffff' }));
                this.battleText.on('pointerdown', () => {
                    this.sound.play('select');
                    this.scene.start('BattleScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad });
                });

                this.controllersText = this.add.text(this.game.config.width / 2, this.game.config.height / 2 + 50, 'CONTROLLERS', {
                    fontSize: '32px',
                    color: '#ffffff'
                }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                this.controllersText.setInteractive();
                this.controllersText.on('pointerover', () => this.controllersText.setStyle({ color: '#ff0000' }));
                this.controllersText.on('pointerout', () => this.controllersText.setStyle({ color: '#ffffff' }));
                this.controllersText.on('pointerdown', () => {
                    this.sound.play('select');
                    this.scene.start('OptionsScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad });
                });

                // Add reticle
                this.selection = 0; // 0 = Battle, 1 = Controllers
                this.reticle = this.add.rectangle(this.battleText.x, this.battleText.y, this.battleText.width + 20, this.battleText.height + 20, 0xffffff, 0).setStrokeStyle(2, 0xff0000);
                this.prevPadButtonStates = new Array(16).fill(false);
                this.prevUp = false;
                this.prevDown = false;
            }

            update() {
                const pad = this.player1Pad || this.player2Pad;
                if (pad) {
                    const currentButtonStates = pad.buttons.map(btn => btn.pressed);
                    const up = currentButtonStates[12] || (pad.axes.length > 1 && pad.axes[1] < -0.1);
                    const down = currentButtonStates[13] || (pad.axes.length > 1 && pad.axes[1] > 0.1);
                    const select = (currentButtonStates[0] && !this.prevPadButtonStates[0]) || (currentButtonStates[2] && !this.prevPadButtonStates[2]); // A or X

                    if (up && !this.prevUp) {
                        this.selection = 0;
                        this.reticle.setPosition(this.battleText.x, this.battleText.y);
                        this.reticle.setSize(this.battleText.width + 20, this.battleText.height + 20);
                    }
                    if (down && !this.prevDown) {
                        this.selection = 1;
                        this.reticle.setPosition(this.controllersText.x, this.controllersText.y);
                        this.reticle.setSize(this.controllersText.width + 20, this.controllersText.height + 20);
                    }
                    if (select) {
                        this.sound.play('select');
                        if (this.selection === 0) {
                            this.scene.start('BattleScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad });
                        } else {
                            this.scene.start('OptionsScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad });
                        }
                    }

                    this.prevUp = up;
                    this.prevDown = down;
                    this.prevPadButtonStates = currentButtonStates;
                }
            }
        }

        // Options Scene
        class OptionsScene extends Phaser.Scene {
            constructor() {
                super({ key: 'OptionsScene' });
            }

            init(data) {
                this.player1Pad = data.player1Pad || null;
                this.player2Pad = data.player2Pad || null;
            }

            create() {
                this.add.rectangle(this.game.config.width / 2, this.game.config.height / 2, this.game.config.width, this.game.config.height, 0x000000);

                this.add.text(this.game.config.width / 2, 50, 'Press any controller button to activate', { fontSize: '20px', color: '#ffffff' }).setOrigin(0.5);

                // Player 1 Controller Layout (Xbox 360 style)
                const pad1Container = this.add.container(300, this.game.config.height / 2);
                const pad1Bg = this.add.rectangle(0, 0, 300, 200, 0x666666);
                pad1Container.add(pad1Bg);
                // D-pad
                const pad1Left = this.add.rectangle(-100, 0, 30, 30, 0xffffff);
                const pad1Right = this.add.rectangle(-40, 0, 30, 30, 0xffffff);
                const pad1Up = this.add.rectangle(-70, -30, 30, 30, 0xffffff);
                const pad1Down = this.add.rectangle(-70, 30, 30, 30, 0xffffff);
                // Face Buttons
                const pad1A = this.add.circle(70, 30, 15, 0x00ff00); // Green
                const pad1B = this.add.circle(100, 0, 15, 0xff0000); // Red
                const pad1X = this.add.circle(40, 0, 15, 0x0000ff); // Blue
                const pad1Y = this.add.circle(70, -30, 15, 0xffff00); // Yellow
                // Shoulder Buttons
                const pad1L1 = this.add.rectangle(-100, -60, 40, 20, 0xffffff);
                const pad1R1 = this.add.rectangle(100, -60, 40, 20, 0xffffff);
                const pad1L2 = this.add.rectangle(-100, -90, 40, 20, 0xcccccc);
                const pad1R2 = this.add.rectangle(100, -90, 40, 20, 0xcccccc);
                // Center Buttons
                const pad1Start = this.add.circle(0, -30, 10, 0xaaaaaa);
                const pad1Back = this.add.circle(-30, -30, 10, 0xaaaaaa);
                pad1Container.add([pad1Left, pad1Right, pad1Up, pad1Down, pad1A, pad1B, pad1X, pad1Y, pad1L1, pad1R1, pad1L2, pad1R2, pad1Start, pad1Back]);
                const pad1Text = this.add.text(300, this.game.config.height / 2 - 150, 'Player 1', { fontSize: '24px', color: '#ffffff' }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                const pad1ReadyText = this.add.text(300, this.game.config.height / 2 - 100, 'Player 1 Ready', { fontSize: '20px', color: '#00ff00' }).setVisible(false).setOrigin(0.5);

                // Player 2 Controller Layout
                const pad2Container = this.add.container(916, this.game.config.height / 2);
                const pad2Bg = this.add.rectangle(0, 0, 300, 200, 0x666666);
                pad2Container.add(pad2Bg);
                const pad2Left = this.add.rectangle(-100, 0, 30, 30, 0xffffff);
                const pad2Right = this.add.rectangle(-40, 0, 30, 30, 0xffffff);
                const pad2Up = this.add.rectangle(-70, -30, 30, 30, 0xffffff);
                const pad2Down = this.add.rectangle(-70, 30, 30, 30, 0xffffff);
                const pad2A = this.add.circle(70, 30, 15, 0x00ff00);
                const pad2B = this.add.circle(100, 0, 15, 0xff0000);
                const pad2X = this.add.circle(40, 0, 15, 0x0000ff);
                const pad2Y = this.add.circle(70, -30, 15, 0xffff00);
                const pad2L1 = this.add.rectangle(-100, -60, 40, 20, 0xffffff);
                const pad2R1 = this.add.rectangle(100, -60, 40, 20, 0xffffff);
                const pad2L2 = this.add.rectangle(-100, -90, 40, 20, 0xcccccc);
                const pad2R2 = this.add.rectangle(100, -90, 40, 20, 0xcccccc);
                const pad2Start = this.add.circle(0, -30, 10, 0xaaaaaa);
                const pad2Back = this.add.circle(-30, -30, 10, 0xaaaaaa);
                pad2Container.add([pad2Left, pad2Right, pad2Up, pad2Down, pad2A, pad2B, pad2X, pad2Y, pad2L1, pad2R1, pad2L2, pad2R2, pad2Start, pad2Back]);
                const pad2Text = this.add.text(916, this.game.config.height / 2 - 150, 'Player 2', { fontSize: '24px', color: '#ffffff' }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                const pad2ReadyText = this.add.text(916, this.game.config.height / 2 - 100, 'Player 2 Ready', { fontSize: '20px', color: '#00ff00' }).setVisible(false).setOrigin(0.5);

                const backText = this.add.text(this.game.config.width / 2, this.game.config.height - 50, 'Back', {
                    fontSize: '32px',
                    color: '#ffffff'
                }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                backText.setInteractive();
                backText.on('pointerover', () => backText.setStyle({ color: '#ff0000' }));
                backText.on('pointerout', () => backText.setStyle({ color: '#ffffff' }));
                backText.on('pointerdown', () => {
                    this.sound.play('select');
                    this.scene.start('StartScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad });
                });

                this.pad1Controls = { left: pad1Left, right: pad1Right, up: pad1Up, down: pad1Down, A: pad1A, B: pad1B, X: pad1X, Y: pad1Y, L1: pad1L1, R1: pad1R1, L2: pad1L2, R2: pad1R2, start: pad1Start, back: pad1Back };
                this.pad2Controls = { left: pad2Left, right: pad2Right, up: pad2Up, down: pad2Down, A: pad2A, B: pad2B, X: pad2X, Y: pad2Y, L1: pad2L1, R1: pad2R1, L2: pad2L2, R2: pad2R2, start: pad2Start, back: pad2Back };
                this.pad1ReadyText = pad1ReadyText;
                this.pad2ReadyText = pad2ReadyText;
                this.pad1ReadyTimer = null;
                this.pad2ReadyTimer = null;
            }

            update() {
                const pad1 = this.player1Pad;
                const pad2 = this.player2Pad;

                // Reset colors
                this.pad1Controls.left.fillColor = 0xffffff;
                this.pad1Controls.right.fillColor = 0xffffff;
                this.pad1Controls.up.fillColor = 0xffffff;
                this.pad1Controls.down.fillColor = 0xffffff;
                this.pad1Controls.A.fillColor = 0x00ff00;
                this.pad1Controls.B.fillColor = 0xff0000;
                this.pad1Controls.X.fillColor = 0x0000ff;
                this.pad1Controls.Y.fillColor = 0xffff00;
                this.pad1Controls.L1.fillColor = 0xffffff;
                this.pad1Controls.R1.fillColor = 0xffffff;
                this.pad1Controls.L2.fillColor = 0xcccccc;
                this.pad1Controls.R2.fillColor = 0xcccccc;
                this.pad1Controls.start.fillColor = 0xaaaaaa;
                this.pad1Controls.back.fillColor = 0xaaaaaa;

                this.pad2Controls.left.fillColor = 0xffffff;
                this.pad2Controls.right.fillColor = 0xffffff;
                this.pad2Controls.up.fillColor = 0xffffff;
                this.pad2Controls.down.fillColor = 0xffffff;
                this.pad2Controls.A.fillColor = 0x00ff00;
                this.pad2Controls.B.fillColor = 0xff0000;
                this.pad2Controls.X.fillColor = 0x0000ff;
                this.pad2Controls.Y.fillColor = 0xffff00;
                this.pad2Controls.L1.fillColor = 0xffffff;
                this.pad2Controls.R1.fillColor = 0xffffff;
                this.pad2Controls.L2.fillColor = 0xcccccc;
                this.pad2Controls.R2.fillColor = 0xcccccc;
                this.pad2Controls.start.fillColor = 0xaaaaaa;
                this.pad2Controls.back.fillColor = 0xaaaaaa;

                if (pad1) {
                    if (pad1.buttons[14].pressed) this.pad1Controls.left.fillColor = 0xffff00;
                    if (pad1.buttons[15].pressed) this.pad1Controls.right.fillColor = 0xffff00;
                    if (pad1.buttons[12].pressed) this.pad1Controls.up.fillColor = 0xffff00;
                    if (pad1.buttons[13].pressed) this.pad1Controls.down.fillColor = 0xffff00;
                    if (pad1.buttons[0].pressed) this.pad1Controls.A.fillColor = 0xffff00;
                    if (pad1.buttons[1].pressed) this.pad1Controls.B.fillColor = 0xffff00;
                    if (pad1.buttons[2].pressed) this.pad1Controls.X.fillColor = 0xffff00;
                    if (pad1.buttons[3].pressed) this.pad1Controls.Y.fillColor = 0xffff00;
                    if (pad1.buttons[4].pressed) this.pad1Controls.L1.fillColor = 0xffff00;
                    if (pad1.buttons[5].pressed) this.pad1Controls.R1.fillColor = 0xffff00;
                    if (pad1.buttons[6].pressed) this.pad1Controls.L2.fillColor = 0xffff00;
                    if (pad1.buttons[7].pressed) this.pad1Controls.R2.fillColor = 0xffff00;
                    if (pad1.buttons[9].pressed) this.pad1Controls.start.fillColor = 0xffff00;
                    if (pad1.buttons[8].pressed) this.pad1Controls.back.fillColor = 0xffff00;

                    if (pad1.buttons.some(btn => btn.pressed)) {
                        if (!this.pad1ReadyTimer) {
                            this.pad1ReadyText.setVisible(true);
                            this.pad1ReadyTimer = this.time.delayedCall(2000, () => {
                                this.pad1ReadyText.setVisible(false);
                                this.pad1ReadyTimer = null;
                            });
                        }
                    }
                }

                if (pad2) {
                    if (pad2.buttons[14].pressed) this.pad2Controls.left.fillColor = 0xffff00;
                    if (pad2.buttons[15].pressed) this.pad2Controls.right.fillColor = 0xffff00;
                    if (pad2.buttons[12].pressed) this.pad2Controls.up.fillColor = 0xffff00;
                    if (pad2.buttons[13].pressed) this.pad2Controls.down.fillColor = 0xffff00;
                    if (pad2.buttons[0].pressed) this.pad2Controls.A.fillColor = 0xffff00;
                    if (pad2.buttons[1].pressed) this.pad2Controls.B.fillColor = 0xffff00;
                    if (pad2.buttons[2].pressed) this.pad2Controls.X.fillColor = 0xffff00;
                    if (pad2.buttons[3].pressed) this.pad2Controls.Y.fillColor = 0xffff00;
                    if (pad2.buttons[4].pressed) this.pad2Controls.L1.fillColor = 0xffff00;
                    if (pad2.buttons[5].pressed) this.pad2Controls.R1.fillColor = 0xffff00;
                    if (pad2.buttons[6].pressed) this.pad2Controls.L2.fillColor = 0xffff00;
                    if (pad2.buttons[7].pressed) this.pad2Controls.R2.fillColor = 0xffff00;
                    if (pad2.buttons[9].pressed) this.pad2Controls.start.fillColor = 0xffff00;
                    if (pad2.buttons[8].pressed) this.pad2Controls.back.fillColor = 0xffff00;

                    if (pad2.buttons.some(btn => btn.pressed)) {
                        if (!this.pad2ReadyTimer) {
                            this.pad2ReadyText.setVisible(true);
                            this.pad2ReadyTimer = this.time.delayedCall(2000, () => {
                                this.pad2ReadyText.setVisible(false);
                                this.pad2ReadyTimer = null;
                            });
                        }
                    }
                }
            }
        }

        // Battle Scene
        class BattleScene extends Phaser.Scene {
            constructor() {
                super({ key: 'BattleScene' });
            }

            init(data) {
                this.player1Pad = data.player1Pad || null;
                this.player2Pad = data.player2Pad || null;
            }

            create() {
                this.add.image(0, 0, 'battlebg').setOrigin(0, 0).setDisplaySize(this.game.config.width, this.game.config.height);

                const grid = [
                    'F@@@1@5@@@@6@@@2@@F',
                    'F@Q@@@@@@@@@@@@@Q@F',
                    'FFF@@@@@@@@@@@@@FFF',
                    'F@@@@@@@@@@@@@@@@@F',
                    'F@@@@@@@A@F@@@@@@@F',
                    'F@@@@@DFFFFFG@@@@@F',
                    'F@@@@@F@@@@@F@@@@@F',
                    'F@@@@@F@@.@@F@@@@@F',
                    'FFG@@@@@@@@@@@@@DFF',
                    'F@@@@@DFF@FFG@@@@@F',
                    'F@@@@@F@@@@@F@@@@@F',
                    'FFFFFFFFFFFFFFFFFFF'
                ];

                this.floors = this.physics.add.staticGroup();
                this.buttons = this.physics.add.staticGroup();
                this.coins = this.physics.add.group();
                this.player1Coins = 0;
                this.player2Coins = 0;
                this.coinSpawnPositions = [];

                for (let i = 0; i < 12; i++) {
                    for (let j = 0; j < 19; j++) {
                        const cell = grid[i][j];
                        const x = j * 64 + 32;
                        const y = i * 64 + 32;

                        if (cell === 'F') this.floors.create(x, y, 'floor');
                        else if (cell === 'D') this.floors.create(x, y, 'floorleft');
                        else if (cell === 'G') this.floors.create(x, y, 'floorright');
                        else if (cell === 'Q') {
                            const button = this.buttons.create(x, y, 'buttonBlue');
                            button.isPressed = false;
                            button.timer = null;
                        }
                        else if (cell === '1') {
                            this.player1 = this.physics.add.sprite(x, y - 32, 'pikachustanding');
                            this.player1.setBounce(0.2);
                            this.player1.setCollideWorldBounds(true);
                            this.player1.isAttacking = false;
                            this.player1.stunned = false;
                            this.player1.cherry = null;
                            this.player1.flipX = false;
                        }
                        else if (cell === '2') {
                            this.player2 = this.physics.add.sprite(x, y - 32, 'eevee-standing');
                            this.player2.setBounce(0.2);
                            this.player2.setCollideWorldBounds(true);
                            this.player2.isAttacking = false;
                            this.player2.stunned = false;
                            this.player2.cherry = null;
                            this.player2.flipX = true;
                        }
                        else if (cell === 'A') {
                            this.cherry = this.physics.add.sprite(x, y - 32, 'cherry');
                            this.cherry.setBounce(0.2);
                        }
                        else if (cell === '5') {
                            this.player1ScoreText = this.add.text(x, y, 'Pikachu: 0', { fontSize: '24px', color: '#ffffff' }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                            this.player1CherryIcon = this.add.image(x + 80, y, 'cherry').setScale(0.5).setVisible(false);
                        }
                        else if (cell === '6') {
                            this.player2ScoreText = this.add.text(x, y, 'Eevee: 0', { fontSize: '24px', color: '#ffffff' }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                            this.player2CherryIcon = this.add.image(x + 80, y, 'cherry').setScale(0.5).setVisible(false);
                        }
                        else if (cell === '.') this.coinSpawnPositions.push({ x, y });
                    }
                }

                this.floors.getChildren().forEach(floor => {
                    floor.body.checkCollision.up = true;
                    floor.body.checkCollision.down = false;
                    floor.body.checkCollision.left = true;
                    floor.body.checkCollision.right = true;
                });

                console.log('Player 1 Pad:', this.player1Pad);
                console.log('Player 2 Pad:', this.player2Pad);

                this.anims.create({
                    key: 'pikachu_stand',
                    frames: this.anims.generateFrameNumbers('pikachustanding', { start: 0, end: 5 }),
                    frameRate: 10,
                    repeat: -1
                });
                this.anims.create({
                    key: 'pikachu_jump',
                    frames: this.anims.generateFrameNumbers('pikachujumping', { start: 0, end: 12 }),
                    frameRate: 20,
                    repeat: 0
                });
                this.anims.create({
                    key: 'pikachu_run',
                    frames: this.anims.generateFrameNumbers('pikachurunning', { start: 0, end: 13 }),
                    frameRate: 15,
                    repeat: -1
                });
                this.anims.create({
                    key: 'pikachu_attack',
                    frames: this.anims.generateFrameNumbers('pikachuattack', { start: 0, end: 11 }),
                    frameRate: 20,
                    repeat: 0
                });
                this.anims.create({
                    key: 'eevee_stand',
                    frames: this.anims.generateFrameNumbers('eevee-standing', { start: 0, end: 9 }),
                    frameRate: 10,
                    repeat: -1
                });
                this.anims.create({
                    key: 'eevee_walk',
                    frames: this.anims.generateFrameNumbers('eevee-walking', { start: 0, end: 5 }),
                    frameRate: 15,
                    repeat: -1
                });
                this.anims.create({
                    key: 'eevee_win',
                    frames: this.anims.generateFrameNumbers('eevee-winning', { start: 0, end: 4 }),
                    frameRate: 10,
                    repeat: -1
                });

                this.physics.add.collider(this.player1, this.floors);
                this.physics.add.collider(this.player2, this.floors);
                this.physics.add.collider(this.cherry, this.floors);
                this.physics.add.overlap(this.player1, this.buttons, this.pressButton, null, this);
                this.physics.add.overlap(this.player2, this.buttons, this.pressButton, null, this);
                this.physics.add.overlap(this.player1, this.cherry, this.collectCherry, null, this);
                this.physics.add.overlap(this.player2, this.cherry, this.collectCherry, null, this);
                this.physics.add.collider(this.player1, this.player2, this.playerCollision, null, this);

                this.helpScreen = this.add.group();
                const helpBg = this.add.rectangle(this.game.config.width / 2, this.game.config.height / 2, this.game.config.width, this.game.config.height, 0x000000, 0.8);
                const helpText = this.add.text(this.game.config.width / 2, this.game.config.height / 2,
                    'Controls:\nPlayer 1:\nWASD - Move\nZ - Jump\nX - Attack\nC - Run\n\nPlayer 2:\nArrows - Move\nB - Jump\nN - Attack\nM - Run\n\nController:\nD-pad/Analog - Move\nA - Jump\nB - Attack\nX - Run\nStart - Pause',
                    { fontSize: '24px', color: '#ffffff', align: 'center' }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                this.helpScreen.addMultiple([helpBg, helpText]);
                this.helpScreen.setVisible(false);

                this.add.text(this.game.config.width - 10, 10, 'PRESS H FOR HELP', { fontSize: '16px', color: '#ffffff' }).setOrigin(1, 0).setShadow(2, 2, '#000000', 2, true, true);

                this.input.keyboard.on('keydown-H', () => this.toggleHelp());
                this.isPaused = false;

                this.player1.play('pikachu_stand');
                this.player2.play('eevee_stand');

                this.prevPad1ButtonStates = new Array(16).fill(false);
                this.prevPad2ButtonStates = new Array(16).fill(false);
            }

            isButtonJustPressed(pad, index, prevStates) {
                if (!pad || index >= pad.buttons.length) return false;
                const current = pad.buttons[index].pressed;
                const previous = prevStates[index];
                return current && !previous;
            }

            update() {
                const pad1 = this.player1Pad;
                const pad2 = this.player2Pad;

                // Update previous states first
                const pad1CurrentStates = pad1 ? pad1.buttons.map(btn => btn.pressed) : new Array(16).fill(false);
                const pad2CurrentStates = pad2 ? pad2.buttons.map(btn => btn.pressed) : new Array(16).fill(false);

                // Player 1 inputs
                const left1 = this.input.keyboard.addKey('A').isDown || (pad1 && (pad1CurrentStates[14] || (pad1.axes.length > 0 && pad1.axes[0] < -0.1)));
                const right1 = this.input.keyboard.addKey('D').isDown || (pad1 && (pad1CurrentStates[15] || (pad1.axes.length > 0 && pad1.axes[0] > 0.1)));
                const jump1 = Phaser.Input.Keyboard.JustDown(this.input.keyboard.addKey('Z')) || (pad1 && pad1CurrentStates[0] && !this.prevPad1ButtonStates[0]);
                const attack1 = Phaser.Input.Keyboard.JustDown(this.input.keyboard.addKey('X')) || (pad1 && pad1CurrentStates[1] && !this.prevPad1ButtonStates[1]);
                const run1 = this.input.keyboard.addKey('C').isDown || (pad1 && pad1CurrentStates[2]);

                // Player 2 inputs
                const left2 = this.input.keyboard.addKey('LEFT').isDown || (pad2 && (pad2CurrentStates[14] || (pad2.axes.length > 0 && pad2.axes[0] < -0.1)));
                const right2 = this.input.keyboard.addKey('RIGHT').isDown || (pad2 && (pad2CurrentStates[15] || (pad2.axes.length > 0 && pad2.axes[0] > 0.1)));
                const jump2 = Phaser.Input.Keyboard.JustDown(this.input.keyboard.addKey('B')) || (pad2 && pad2CurrentStates[0] && !this.prevPad2ButtonStates[0]);
                const attack2 = Phaser.Input.Keyboard.JustDown(this.input.keyboard.addKey('N')) || (pad2 && pad2CurrentStates[1] && !this.prevPad2ButtonStates[1]);
                const run2 = this.input.keyboard.addKey('M').isDown || (pad2 && pad2CurrentStates[2]);

                // Pause with Start button
                if ((pad1 && pad1CurrentStates[9] && !this.prevPad1ButtonStates[9]) || (pad2 && pad2CurrentStates[9] && !this.prevPad2ButtonStates[9])) {
                    this.toggleHelp();
                }

                // Debug inputs
                if (pad1) {
                    console.log('P1 Left:', pad1CurrentStates[14], 'Axis:', pad1.axes[0], 'Jump:', pad1CurrentStates[0]);
                }

                // Player 1 controls
                if (!this.player1.stunned) {
                    if (left1) {
                        this.player1.setVelocityX(run1 ? -320 : -160);
                        this.player1.flipX = true;
                        if (this.player1.body.onFloor()) this.player1.play('pikachu_run', true);
                    } else if (right1) {
                        this.player1.setVelocityX(run1 ? 320 : 160);
                        this.player1.flipX = false;
                        if (this.player1.body.onFloor()) this.player1.play('pikachu_run', true);
                    } else {
                        this.player1.setVelocityX(0);
                        if (this.player1.body.onFloor() && !this.player1.isAttacking) this.player1.play('pikachu_stand', true);
                    }

                    if (jump1 && this.player1.body.onFloor()) {
                        this.player1.setVelocityY(-450);
                        this.player1.play('pikachu_jump', true);
                        this.sound.play('jump');
                    }

                    if (attack1 && !this.player1.isAttacking) {
                        this.player1.isAttacking = true;
                        this.player1.play('pikachu_attack', true);
                        this.checkAttack(this.player1, this.player2);
                        this.time.delayedCall(600, () => { this.player1.isAttacking = false; });
                    }
                }

                // Player 2 controls
                if (!this.player2.stunned) {
                    if (left2) {
                        this.player2.setVelocityX(run2 ? -320 : -160);
                        this.player2.flipX = true;
                        if (this.player2.body.onFloor()) this.player2.play('eevee_walk', true);
                    } else if (right2) {
                        this.player2.setVelocityX(run2 ? 320 : 160);
                        this.player2.flipX = false;
                        if (this.player2.body.onFloor()) this.player2.play('eevee_walk', true);
                    } else {
                        this.player2.setVelocityX(0);
                        if (this.player2.body.onFloor() && !this.player2.isAttacking) this.player2.play('eevee_stand', true);
                    }

                    if (jump2 && this.player2.body.onFloor()) {
                        this.player2.setVelocityY(-450);
                        this.player2.play('eevee_stand', true);
                        this.sound.play('jump');
                    }

                    if (attack2 && !this.player2.isAttacking) {
                        this.player2.isAttacking = true;
                        this.player2.setTexture('eevee-kick');
                        this.checkAttack(this.player2, this.player1);
                        this.time.delayedCall(300, () => {
                            this.player2.isAttacking = false;
                            this.player2.play('eevee_stand', true);
                        });
                    }
                }

                if (!this.player1.body.onFloor() && !this.player1.isAttacking) this.player1.play('pikachu_jump', true);
                if (!this.player2.body.onFloor() && !this.player2.isAttacking) this.player2.play('eevee_stand', true);

                // Update previous states
                this.prevPad1ButtonStates = pad1CurrentStates;
                this.prevPad2ButtonStates = pad2CurrentStates;
            }

            checkAttack(attacker, defender) {
                const tileSize = 64;
                const attackerTileX = Math.floor(attacker.x / tileSize);
                const attackerTileY = Math.floor(attacker.y / tileSize);
                const attackDirection = attacker.flipX ? -1 : 1;
                const attackTileX = attackerTileX + attackDirection;
                const defenderTileX = Math.floor(defender.x / tileSize);
                const defenderTileY = Math.floor(defender.y / tileSize);

                if (attackTileX === defenderTileX && attackerTileY === defenderTileY) {
                    this.damagePlayer(defender);
                }
            }

            pressButton(player, button) {
                if (!button.isPressed && player.body.velocity.y > 0 && player.y < button.y) {
                    button.isPressed = true;
                    button.setTexture('buttonBlue_pressed');
                    this.sound.play('buttonPress');
                    this.spawnCoin();
                    button.timer = this.time.delayedCall(5000, () => {
                        button.isPressed = false;
                        button.setTexture('buttonBlue');
                        button.timer = null;
                    });
                }
            }

            spawnCoin() {
                const spawnPos = this.coinSpawnPositions[0] || { x: this.game.config.width / 2, y: this.game.config.height / 2 };
                const coin = this.coins.create(spawnPos.x, spawnPos.y, 'coinGold');
                coin.body.allowGravity = false;
                coin.setBounce(0);
                this.tweens.add({
                    targets: coin,
                    x: { from: spawnPos.x - 100, to: spawnPos.x + 100 },
                    duration: 2000,
                    yoyo: true,
                    repeat: -1,
                    onUpdate: () => coin.setAlpha(coin.alpha === 1 ? 0.5 : 1)
                });
                this.physics.add.overlap(this.player1, coin, this.collectCoin, null, this);
                this.physics.add.overlap(this.player2, coin, this.collectCoin, null, this);
            }

            collectCoin(player, coin) {
                coin.destroy();
                this.sound.play('coin');
                if (player === this.player1) {
                    this.player1Coins++;
                    this.player1ScoreText.setText('Pikachu: ' + this.player1Coins);
                } else {
                    this.player2Coins++;
                    this.player2ScoreText.setText('Eevee: ' + this.player2Coins);
                }
                if (this.player1Coins >= 21 || this.player2Coins >= 21) this.endGame();
            }

            collectCherry(player, cherry) {
                if (!player.cherry) {
                    player.cherry = cherry;
                    cherry.setVisible(false);
                    if (player === this.player1) this.player1CherryIcon.setVisible(true);
                    else this.player2CherryIcon.setVisible(true);
                }
            }

            playerCollision(playerA, playerB) {
                if (playerA.isAttacking && !playerB.stunned) this.damagePlayer(playerB);
                else if (playerB.isAttacking && !playerA.stunned) this.damagePlayer(playerA);
                else if (playerA.body.velocity.y > 0 && playerA.y < playerB.y && !playerB.stunned) this.damagePlayer(playerB);
                else if (playerB.body.velocity.y > 0 && playerB.y < playerA.y && !playerA.stunned) this.damagePlayer(playerA);
            }

            damagePlayer(player) {
                this.sound.play('squish');
                player.stunned = true;
                player.setScale(1, 0.8);
                this.tweens.add({
                    targets: player,
                    alpha: 0.5,
                    duration: 250,
                    yoyo: true,
                    repeat: 1,
                    onComplete: () => {
                        player.stunned = false;
                        player.setScale(1);
                        player.setAlpha(1);
                    }
                });

                if (player.cherry) {
                    const cherry = player.cherry;
                    cherry.setVisible(true);
                    cherry.x = player.x + (player.flipX ? -256 : 256);
                    cherry.y = player.y;
                    this.tweens.add({
                        targets: cherry,
                        alpha: 0.5,
                        duration: 300,
                        yoyo: true,
                        repeat: 5,
                        onComplete: () => cherry.setAlpha(1)
                    });
                    if (player === this.player1) this.player1CherryIcon.setVisible(false);
                    else this.player2CherryIcon.setVisible(false);
                    player.cherry = null;
                }
            }

            endGame() {
                this.physics.pause();
                const score1 = this.player1Coins + (this.player1.cherry ? 5 : 0);
                const score2 = this.player2Coins + (this.player2.cherry ? 5 : 0);
                let winner = score1 > score2 ? this.player1 : score2 > score1 ? this.player2 : null;

                const scoreDisplay = this.add.text(this.game.config.width / 2, this.game.config.height / 2 - 100, '', { fontSize: '32px', color: '#ffffff' }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                this.time.delayedCall(1000, () => scoreDisplay.setText(`Pikachu: ${this.player1Coins}`));
                this.time.delayedCall(2000, () => scoreDisplay.setText(`Pikachu: ${this.player1Coins} + ${this.player1.cherry ? 5 : 0} = ${score1}`));
                this.time.delayedCall(3000, () => scoreDisplay.setText(`Eevee: ${this.player2Coins}`));
                this.time.delayedCall(4000, () => scoreDisplay.setText(`Eevee: ${this.player2Coins} + ${this.player2.cherry ? 5 : 0} = ${score2}`));
                this.time.delayedCall(5000, () => {
                    scoreDisplay.setText(winner === this.player1 ? 'Pikachu Wins!' : winner === this.player2 ? 'Eevee Wins!' : 'Tie!');
                    this.children.list.forEach(child => {
                        if (child !== winner && child !== scoreDisplay && child !== this.rematchText && child !== this.exitText) child.setVisible(false);
                    });
                    if (winner === this.player1) this.player1.play('pikachu_attack', true);
                    else if (winner === this.player2) this.player2.play('eevee_win', true);
                });

                this.rematchText = this.add.text(this.game.config.width / 2, this.game.config.height / 2 + 50, 'Rematch', {
                    fontSize: '32px',
                    color: '#ff0000'
                }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);
                this.exitText = this.add.text(this.game.config.width / 2, this.game.config.height / 2 + 100, 'Exit', {
                    fontSize: '32px',
                    color: '#ffffff'
                }).setOrigin(0.5).setShadow(2, 2, '#000000', 2, true, true);

                this.rematchText.setInteractive();
                this.rematchText.on('pointerover', () => { this.rematchText.setStyle({ color: '#ff0000' }); this.sound.play('select'); });
                this.rematchText.on('pointerout', () => this.rematchText.setStyle({ color: '#ff0000' }));
                this.rematchText.on('pointerdown', () => this.scene.restart());

                this.exitText.setInteractive();
                this.exitText.on('pointerover', () => { this.exitText.setStyle({ color: '#ff0000' }); this.sound.play('select'); });
                this.exitText.on('pointerout', () => this.exitText.setStyle({ color: '#ffffff' }));
                this.exitText.on('pointerdown', () => this.scene.start('StartScene', { player1Pad: this.player1Pad, player2Pad: this.player2Pad }));
            }

            toggleHelp() {
                this.isPaused = !this.isPaused;
                this.helpScreen.setVisible(this.isPaused);
                if (this.isPaused) {
                    this.physics.pause();
                    this.sound.play('pause');
                } else {
                    this.physics.resume();
                }
            }
        }

        // Game Configuration
        const config = {
            type: Phaser.AUTO,
            width: 1216,
            height: 768,
            parent: 'game-container',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false
                }
            },
            input: {
                gamepad: true
            },
            scene: [ControllerDetectionScene, StartScene, OptionsScene, BattleScene]
        };

        const game = new Phaser.Game(config);
    </script>
</body>
</html>